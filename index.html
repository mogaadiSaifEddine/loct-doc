<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Technical Documentation</title>
    <!-- Add marked library from CDN -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <!-- Add highlight.js for code syntax highlighting -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css" />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background: #f5f5f5;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        background: #fff;
        padding: 1rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        margin-bottom: 2rem;
      }

      header h1 {
        max-width: 1200px;
        margin: 0 auto;
        font-size: 1.5rem;
      }

      .layout {
        display: grid;
        grid-template-columns: 250px 1fr;
        gap: 2rem;
      }

      .sidebar {
        background: white;
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        height: fit-content;
      }

      .content {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .nav-item {
        display: block;
        padding: 0.5rem 1rem;
        color: #333;
        text-decoration: none;
        border-radius: 4px;
        margin-bottom: 0.5rem;
        cursor: pointer;
      }

      .nav-item:hover {
        background: #f0f0f0;
      }

      .nav-item.active {
        background: #e3f2fd;
        color: #1976d2;
      }

      .search-box {
        width: 100%;
        padding: 0.5rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 1rem;
      }

      /* Documentation Styles */
      .markdown-content h1 {
        font-size: 2em;
        border-bottom: 1px solid #eaecef;
        margin-bottom: 1em;
        padding-bottom: 0.3em;
      }

      .markdown-content h2 {
        font-size: 1.5em;
        margin-top: 1.5em;
        margin-bottom: 0.5em;
        border-bottom: 1px solid #eaecef;
        padding-bottom: 0.3em;
      }

      .markdown-content h3 {
        font-size: 1.25em;
        margin-top: 1.5em;
        margin-bottom: 0.5em;
      }

      .markdown-content p {
        margin: 1em 0;
      }

      .markdown-content code {
        background: #f6f8fa;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-family: ui-monospace, SFMono-Regular, Consolas, monospace;
        font-size: 0.9em;
      }

      .markdown-content pre {
        background: #f6f8fa;
        padding: 1em;
        border-radius: 6px;
        overflow-x: auto;
        margin: 1em 0;
      }

      .markdown-content pre code {
        background: transparent;
        padding: 0;
        border-radius: 0;
      }

      .markdown-content table {
        border-collapse: collapse;
        width: 100%;
        margin: 1em 0;
      }

      .markdown-content th,
      .markdown-content td {
        border: 1px solid #dfe2e5;
        padding: 6px 13px;
      }

      .markdown-content th {
        background: #f6f8fa;
      }

      .markdown-content ul,
      .markdown-content ol {
        margin: 1em 0;
        padding-left: 2em;
      }

      @media (max-width: 768px) {
        .layout {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>

  <body>
    <header>
      <h1>Technical Documentation</h1>
    </header>

    <div class="container">
      <div class="layout">
        <aside class="sidebar">
          <input
            type="text"
            class="search-box"
            placeholder="Search..."
            id="search" />
          <nav id="nav">
            <a class="nav-item active" data-doc="add-path">Add Path
              Component</a>
            <a class="nav-item" data-doc="websocket">WebSocket Refresh</a>
            <a class="nav-item" data-doc="angular_19_setup">
              Angular 19 Setup
            </a>
            <a class="nav-item" data-doc="point-service"> Point Service (State
              management && Queue) </a>
          </nav>
        </aside>

        <main class="content">
          <div id="content" class="markdown-content"></div>
        </main>
      </div>
    </div>

    <script>
      window.addEventListener("offline", () => {
        console.log('offli');
        
      })
      // Configure marked with syntax highlighting
      marked.setOptions({
        highlight: function (code, lang) {
          return hljs.highlightAuto(code).value;
        },
        breaks: true,
        gfm: true,
      });

      // Documentation content
      const docs = {
        "add-path": ` # AddPathComponent Documentation

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
- [API Reference](#api-reference)
- [Examples](#examples)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Overview

The \`AddPathComponent\` is a sophisticated Angular component designed for path management and visualization using Google Maps. It provides functionality for creating, modifying, and managing paths with support for multiple creation modes and travel types.

### Core Functionality

- Path creation and management
- Google Maps integration
- Multiple travel mode support
- KML file import/export
- Interactive point management

## Features

### 1. Multiple Path Creation Modes

#### Create Path Mode

Manual path creation through point selection:

\`\`\`typescript
setMode("createPath");
// Enables direct point placement on map
\`\`\`

#### Generate Path Mode

Automated path generation between points:

\`\`\`typescript
setMode("generatePath");
// Enables start/end point selection with automatic path generation
\`\`\`

#### Import Path Mode

Support for KML file imports:

\`\`\`typescript
// File input handling
changeFile(event) {
  const files: FileList = event.srcElement.files;
  this.readFile(files[0]);
}
\`\`\`

### 2. Travel Modes

Supports multiple Google Maps travel modes:

- DRIVING
- WALKING
- BICYCLING

\`\`\`typescript
changeTravelMode(mode: google.maps.TravelMode) {
  this.defaultTravelmode = mode;
  this.generatePath();
}
\`\`\`

## Installation

### Prerequisites

- Angular 17+
- Google Maps JavaScript API
- @angular/google-maps package

### Required Dependencies

\`\`\`json
{
  "dependencies": {
    "@angular/google-maps": "^x.x.x",
    "@angular/material": "^x.x.x",
    "@ngx-translate/core": "^x.x.x"
  }
}
\`\`\`

### Component Integration

\`\`\`typescript
import { AddPathComponent } from './components/add-path/add-path.component';

@NgModule({
  declarations: [AddPathComponent],
  exports: [AddPathComponent]
})
\`\`\`

## Usage

### Basic Implementation

1. Template Usage:

\`\`\`html
<locatify-add-path
  [tour]="tourData"
  [addPathSubject]="pathSubject"
  (colorChange)="onColorChange($event)"
  (saveTour)="onSaveTour()"
  (close)="onClose()"
>
</locatify-add-path>
\`\`\`

2. Component Integration:

\`\`\`typescript
export class ParentComponent {
  tourData: Tour;
  pathSubject = new Subject<any>();

  onColorChange(color: string) {
    // Handle color change
  }

  onSaveTour() {
    // Handle save
  }
}
\`\`\`

## API Reference

### Inputs

| Input          | Type            | Description                    |
| -------------- | --------------- | ------------------------------ |
| tour           | Tour            | Tour configuration object      |
| addPathSubject | Observable<any> | Subject for adding path points |

### Outputs

| Output      | Type         | Description              |
| ----------- | ------------ | ------------------------ |
| colorChange | EventEmitter | Emits on color changes   |
| saveTour    | EventEmitter | Emits on tour save       |
| close       | EventEmitter | Emits on component close |

### Methods

#### Public Methods

\`\`\`typescript
setMode(mode: CreatePathMode): void
// Sets the current path creation mode

generatePath(): void
// Generates path between selected points

addDestination(): void
// Adds waypoint to current path

bulkCreate(): void
// Creates multiple path points

clearSelection(): void
// Resets all selections
\`\`\`

#### Private Methods

\`\`\`typescript
private resetPaths(): void
// Resets path data

private handleCreatePathMode(path: Path): void
// Handles path creation in create mode

private handleGeneratePathMode(path: Path): void
// Handles path creation in generate mode
\`\`\`

## Examples

### 1. Basic Path Creation

\`\`\`typescript
// Component
export class MyComponent {
  @ViewChild(AddPathComponent) addPath: AddPathComponent;

  createSimplePath() {
    this.addPath.setMode("createPath");
    // Ready for point selection
  }
}
\`\`\`

### 2. Automated Path Generation

\`\`\`typescript
// Generate path between two points
const startPoint = { lat: 40.7128, lng: -74.006 };
const endPoint = { lat: 40.7614, lng: -73.9776 };

this.addPath.startPoint = startPoint;
this.addPath.endPoint = endPoint;
this.addPath.generatePath();
\`\`\`

### 3. File Import

\`\`\`typescript
// Template
<input type="file" (change)="addPath.changeFile($event)" accept=".kml">

// Component
handleFileImport(event: Event) {
  this.addPath.setMode('importPath');
  this.addPath.changeFile(event);
}
\`\`\`

## Troubleshooting

### Common Issues

1. **Path Generation Fails**

   - Verify API key configuration
   - Check coordinate validity
   - Ensure network connectivity

2. **File Import Issues**

   - Verify file format (KML only)
   - Check file size limits
   - Validate coordinate format

3. **Performance Issues**
   - Implement path point limiting
   - Use debouncing for updates
   - Optimize render cycles

### Debug Tips

1. Enable console logging:

\`\`\`typescript
private debugMode = true;

private log(message: string) {
  if (this.debugMode) {
    console.log('[AddPath]: \${message}');
  }
}
\`\`\`

2. Monitor state changes:

\`\`\`typescript
@Input() set tour(value: Tour) {
  this.log('Tour updated: \${JSON.stringify(value)}');
  this._tour = value;
}
\`\`\`
`,

        websocket: `# WebSocket Refresh Feature Documentation

## Overview

The WebSocket Refresh feature implements real-time project synchronization with automatic refresh handling and user confirmation. This feature ensures that project data remains synchronized across multiple sessions while providing a smooth user experience.

## Key Concepts

- Real-time synchronization via WebSocket
- Debounced refresh to prevent overload
- User confirmation through dialog
- Automatic route and point updates
- Proper cleanup and resource management

## Implementation

### 1. Core Properties

\`\`\`typescript
private refreshTrigger = new Subject<void>();
private refreshTimer: Subscription | null = null;
private readonly REFRESH_COOLDOWN = 2000; // 2 seconds cooldown
private isRefreshPending = false;
\`\`\`

### 2. WebSocket Connection Setup

\`\`\`typescript
private initializeWebSocketRefresh() {
  this.webSocketRefresh = this.webSocketService.instantProjectId
    .pipe(
      filter(value => value === this.tour?.id),  // Only handle relevant updates
      tap(() => this.refreshTrigger.next())      // Trigger refresh workflow
    )
    .subscribe();
}
\`\`\`

### 3. Refresh Handler Setup

\`\`\`typescript
private initializeRefreshHandler() {
  this.refreshTrigger
    .pipe(
      debounceTime(this.REFRESH_COOLDOWN),     // Prevent rapid refreshes
      filter(() => !this.isRefreshPending)      // Prevent multiple dialogs
    )
    .subscribe(() => this.showRefreshDialog());
}
\`\`\`

### 4. Dialog Management

\`\`\`typescript
private showRefreshDialog() {
  if (this.isRefreshPending) return;

  this.isRefreshPending = true;
  this.dialog.open(CustomConfirmModalComponent, {
    ...customConfirmModalstyle,
    data: this.getDialogConfig(),
    disableClose: true
  })
  .afterClosed()
  .pipe(
    switchMap(confirmed => this.handleDialogResponse(confirmed)),
    finalize(() => this.isRefreshPending = false)
  )
  .subscribe();
}
\`\`\`

### 5. Data Refresh Flow

\`\`\`typescript
private handleDialogResponse(confirmed: boolean) {
  if (!confirmed) return EMPTY;
  return this.refreshProjectData().pipe(
    tap(() => this.updateProjectStatus())
  );
}

private refreshProjectData() {
  return this.pointService.getPoints(this.tour.id).pipe(
    map(res => this.updateRouteAndPoints(res)),
    catchError(error => {
      console.error('Error refreshing points:', error);
      return EMPTY;
    })
  );
}
\`\`\`

### 6. Route and Status Updates

\`\`\`typescript
private updateRouteAndPoints(points: any) {
  const currentParams = { ...this.route.snapshot.queryParams };
  this.handleWayPoints(points);
  this.updateRouteParams(currentParams);
  this.pointService.reloadPoint.next(true);
  return points;
}

private updateProjectStatus() {
  this.projectService.isProjectRefreshed.next(true);
  this.refreshTourInfo();
}
\`\`\`

## Usage Guide

### Basic Setup

1. Initialize in component:

\`\`\`typescript
ngOnInit() {
  this.initializeWebSocketRefresh();
  this.initializeRefreshHandler();
}
\`\`\`

2. Implement cleanup:

\`\`\`typescript
ngOnDestroy() {
  this.cleanup();
}

private cleanup() {
  this.refreshTrigger.complete();
  if (this.refreshTimer) {
    this.refreshTimer.unsubscribe();
  }
  if (this.webSocketRefresh) {
    this.webSocketRefresh.unsubscribe();
  }
}
\`\`\`

## Common Issues and Solutions

### 1. Multiple Refresh Dialogs

**Problem**: Multiple dialogs appearing simultaneously
**Solution**: Use isRefreshPending flag and proper cleanup

\`\`\`typescript
if (this.isRefreshPending) return;
this.isRefreshPending = true;
// ... handle refresh
\`\`\`

### 2. Memory Leaks

**Problem**: Subscriptions not properly cleaned up
**Solution**: Implement thorough cleanup

\`\`\`typescript
private cleanup() {
  this.refreshTrigger.complete();
  this.webSocketRefresh?.unsubscribe();
  this.refreshTimer?.unsubscribe();
}
\`\`\`

### 3. Missed Updates

**Problem**: Updates not being processed
**Solution**: Verify filter conditions and subscription setup

\`\`\`typescript
// Ensure proper filter conditions
filter((value) => value === this.tour?.id);
\`\`\`

## Debug Tips

### 1. Add Logging

\`\`\`typescript
private log(message: string) {
  console.log('[WebSocket Refresh]: \${message}');
}
\`\`\`

### 2. Track State Changes

\`\`\`typescript
private updateRefreshState(state: boolean) {
  this.log(\`Refresh pending: \${state}\`);
  this.isRefreshPending = state;
}
\`\`\`

## Configuration Options

\`\`\`typescript
const CONFIG = {
  REFRESH_COOLDOWN: 2000, // Debounce time in ms
  RETRY_ATTEMPTS: 3, // Number of refresh attempts
  AUTO_REFRESH: false, // Skip confirmation dialog
};
\`\`\`

## API Reference

### Core Methods

| Method                     | Description                  |
| -------------------------- | ---------------------------- |
| initializeWebSocketRefresh | Sets up WebSocket connection |
| initializeRefreshHandler   | Configures refresh workflow  |
| showRefreshDialog          | Manages user confirmation    |
| handleDialogResponse       | Processes user response      |
| refreshProjectData         | Fetches updated data         |
| updateRouteAndPoints       | Updates UI with new data     |

### Events

| Event              | Description                  |
| ------------------ | ---------------------------- |
| refreshTrigger     | Signals need for refresh     |
| isProjectRefreshed | Indicates successful refresh |

## Dependencies

- Angular Material Dialog
- RxJS Operators
- WebSocket Service
- Project Service
- Point Service

`,
        angular_19_setup: `# Guide for Setting Up the Project after Upgrading to Angular 19

This document provides a step-by-step guide for developers to set up the project on their local machines after the upgrade to Angular 19. Follow these instructions to ensure compatibility with the updated project.

---

## Steps to Re-Setup the Project

### Uninstall Angular CLI Globally

\`\`\`bash

run 'npm uninstall -g @angular/cli'
\`\`\`
### Install Angular CLI Globally (Version 19)
\`\`\`bash
run 'npm install -g @angular/cli@19'
\`\`\`

### Pull the Latest Changes from the Main Branch
\`\`\`bash

run 'git pull origin new-angular-version'
\`\`\`

### Remove Existing Node Modules

remove package-lock.json file

### Remove Existing Node Modules
\`\`\`bash

run 'rm -rf node_modules'
\`\`\`


### Install Updated Dependencies
\`\`\`bash

run 'npm install'
\`\`\`

---

These steps will ensure your local environment is correctly set up to work with the upgraded Angular 19 project.
`,
        "point-service": `# PointService Documentation

## Overview
The PointService is an Angular injectable service that manages waypoints for tours. It handles CRUD operations for waypoints, manages state using BehaviorSubjects, and implements a queue system for handling point updates.

## Dependencies
- @angular/common/http: For HTTP requests
- @angular/core: For dependency injection
- rxjs: For reactive programming features
- Environment configuration
- OfflineApiService
- ToastrTranslationServiceService
- WebSocketService

## Service Properties

### Observables
\`\`\`typescript

 pointsSubject: BehaviorSubject<WayPoint[]> // Manages the current state of waypoints
 selectedLanguage: BehaviorSubject<Language> // Tracks the selected language
 reloadPoint: BehaviorSubject<boolean> // Triggers point reloading
\`\`\`

### Queue System
\`\`\`typescript
 pointQueue$: Subject: // Handles point update operations
 contentQueue$: Subject: // Handles content update operations
 queue$: Subject: // Main queue for managing all update operations
\`\`\`

## Methods

### State Management

### Overview
The PointService implements a robust state management system using RxJS BehaviorSubjects. This system maintains the current state of waypoints, selected language, and reload triggers while ensuring data consistency across the application.

### State Properties

#### BehaviorSubjects
\`\`\`typescript
pointsSubject = new BehaviorSubject<WayPoint[]>([])
selectedLanguage = new BehaviorSubject<Language>(null)
reloadPoint = new BehaviorSubject(false)
\`\`\`

### State Update Patterns

#### Direct State Updates
\`\`\`typescript
loadPoints(points: WayPoint[]): void {
    this.pointsSubject.next(points);
}
\`\`\`
Directly updates the entire waypoints collection.

#### Incremental State Updates

1. **Adding Points**
\`\`\`typescript
// Inside addPoint method
this.pointsSubject.next([...this.pointsSubject.getValue(), newPoint]);
\`\`\`

2. **Updating Points**
\`\`\`typescript
// Inside updatePoint method
const points = this.pointsSubject.getValue();
const index = points.findIndex(p => p.id === updatedPoint.id);
if (index !== -1) {
    points[index] = updatedPoint;
    this.pointsSubject.next(points);
}
\`\`\`

3. **Deleting Points**
\`\`\`typescript
// Inside deletePoint method
const points = this.pointsSubject.getValue();
const index = points.findIndex(p => p.id === pointId);
if (index !== -1) {
    points.splice(index, 1);
    this.pointsSubject.next(points);
}
\`\`\`

### State Access Methods

#### Synchronous State Access
\`\`\`typescript
getLocalPoint(pointId: number): WayPoint | undefined {
    return this.pointsSubject.getValue().find(p => p.id == pointId);
}
\`\`\`

#### Asynchronous State Subscription
\`\`\`typescript
// Example usage in components
this.pointService.pointsSubject.subscribe(points => {
    // Handle points update
});
\`\`\`

### State Management Best Practices

1. **Immutable Updates**
   - Always create new arrays when updating state
   - Use spread operator for array modifications
   - Never directly modify the BehaviorSubject value

2. **Atomic Updates**
   - Each state update should be atomic and complete
   - Handle edge cases and null checks
   - Maintain data consistency

3. **State Synchronization**
   - Coordinate with WebSocket updates
   - Handle concurrent modifications
   - Maintain consistency with server state

4. **Error Handling**
   - Rollback state on failed operations
   - Maintain previous state on error
   - Notify users of state update failures

### State Flow Diagram

\`\`\`mermaid
graph TD
    A[HTTP Request] --> B[Queue System]
    B --> C{Update Type}
    C -->|Point Update| D[Execute Update]
    C -->|Content Update| E[Execute Content Update]
    D --> F[Update BehaviorSubject]
    E --> F
    F --> G[Notify WebSocket]
    G --> H[Update UI]
\`\`\`

### Example State Management Implementations

#### Component Integration
\`\`\`typescript
@Component({
  // ...
})
export class WaypointComponent implements OnInit {
  points$: Observable<WayPoint[]>;

  constructor(private pointService: PointService) {
    this.points$ = this.pointService.pointsSubject.asObservable();
  }

  updatePoint(point: WayPoint) {
    this.pointService.updatePoint(projectId, point).subscribe({
      next: (updatedPoint) => {
        // State is automatically updated via pointsSubject
      },
      error: (error) => {
        // Handle error
      }
    });
  }
}
\`\`\`

#### State Change Detection
\`\`\`typescript
// Track state changes
this.pointService.pointsSubject
  .pipe(
    distinctUntilChanged(),
    map(points => points.length)
  )
  .subscribe(count => {
    // Handle point count changes
  });
\`\`\`

### API Operations

#### Points Retrieval
\`\`\`typescript
getPoints(projectId: number): Observable<WayPoint[]>
\`\`\`
Fetches all waypoints for a specific project from the API.

#### Single Point Retrieval
\`\`\`typescript
getPoint(projectId: number, pointId: number): Observable<WayPoint>
\`\`\`
Retrieves a specific waypoint by project ID and point ID.

#### Point Creation
\`\`\`typescript
addPoint(projectId: number, point: WayPoint): Observable<WayPoint>
\`\`\`
Creates a new waypoint in the specified project.

#### Point Updates
\`\`\`typescript
updatePoint(projectId: number, updatedPoint: WayPoint): Observable<WayPoint>
\`\`\`
Updates an existing waypoint. This method uses the queue system for managing updates.

#### Coordinate Updates
\`\`\`typescript
updateWaypointCoords(tourId: number, updatedPoint: WayPoint): Observable<WayPoint>
\`\`\`
Specifically updates the coordinates (latitude and longitude) of a waypoint.

#### Content Updates
\`\`\`typescript
updatePointContent(pointId: number, content: any, templateId: number): Observable<any>
\`\`\`
Updates the content of a waypoint using the queue system.

#### Point Deletion
\`\`\`typescript
deletePoint(projectId: number, pointId: number): Observable<WayPoint>
\`\`\`
Removes a waypoint from the system.

## Queue System Implementation

The service implements a queue system for managing updates using RxJS's concatMap operator. This ensures that updates are processed sequentially and prevents race conditions.

### Queue Processing
\`\`\`typescript
private initQueue()
\`\`\`
Initializes the queue system and handles:
- Point updates
- Content updates
- Error handling
- Success notifications

### Queue Execution Methods
\`\`\`typescript
private executeUpdatePoint(projectId: number, updatedPoint: WayPoint): Observable<WayPoint>
private executeUpdatePointContent(pointId: number, content: any, templateId: number): Observable<any>
\`\`\`
These methods handle the actual API calls for updates in the queue.

## Error Handling

The service includes a generic error handler:
\`\`\`typescript
private handleError<T>(operation = "operation", result?: T)
\`\`\`
Features:
- Logs errors to console
- Returns a safe fallback value
- Maintains type safety using generics

## WebSocket Integration
The service integrates with WebSocket functionality through the WebSocketService:
- Uses channel parameters for real-time updates
- Maintains synchronization across clients

## Best Practices
1. Always subscribe to observables when making API calls
2. Use the queue system for updates to prevent race conditions
3. Handle errors appropriately using the provided error handler
4. Maintain state consistency through the pointsSubject

## Usage Example

\`\`\`typescript
// Inject the service
constructor(private pointService: PointService) {}

// Get points for a project
this.pointService.getPoints(projectId).subscribe(
  points => {
    // Handle points
  }
);

// Update a point
this.pointService.updatePoint(projectId, updatedPoint).subscribe(
  result => {
    // Handle success
  }
);
\`\`\``,
      };

      // Initialize
      let currentDoc = "add-path";

      // Wait for document to be fully loaded
      document.addEventListener("DOMContentLoaded", () => {
        // Initialize syntax highlighting
        hljs.highlightAll();

        // Initial content update
        updateContent();

        // Event Listeners
        document.getElementById("nav").addEventListener("click", (e) => {
          if (e.target.classList.contains("nav-item")) {
            document.querySelectorAll(".nav-item").forEach((item) => {
              item.classList.remove("active");
            });
            e.target.classList.add("active");
            currentDoc = e.target.dataset.doc;
            updateContent();
          }
        });

        document.getElementById("search").addEventListener("input", (e) => {
          const query = e.target.value.toLowerCase();
          const items = document.querySelectorAll(".nav-item");

          items.forEach((item) => {
            console.log(item.dataset.doc);

            const docId = item.dataset.doc;
            const content = docs[docId].toLowerCase();
            if (content.includes(query) || docId.includes(query)) {
              item.style.display = "block";
            } else {
              item.style.display = "none";
            }
          });
        });
      });

      function updateContent() {
        const content = document.getElementById("content");
        content.innerHTML = marked.parse(docs[currentDoc] || "");
        // Highlight code blocks in the new content
        content.querySelectorAll("pre code").forEach((block) => {
          hljs.highlightBlock(block);
        });
      }
    </script>
  </body>
</html>
